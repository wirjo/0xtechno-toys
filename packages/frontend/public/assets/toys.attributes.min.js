function calculateFeatures(tokenData) {

    let hash = tokenData.hash
    let count;
    const PERLIN_YWRAPB = 4;
    const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
    const PERLIN_ZWRAPB = 8;
    const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
    const PERLIN_SIZE = 4095;
    const PERLIN_OCTAVES = 4; // default to medium smooth
    const PERLIN_AMP_FALLOFF = 0.5; // 50% reduction/octave
    const RANDOM_DEC_PRECISION = 1000;
    
    const scaled_cosine = i => 0.5 * (1.0 - Math.cos(i * Math.PI));
    
    class RandomAB {
    
        constructor(seed)
        {
            // Seed must be a nonzero integer
            this.seed = seed;
            this.perlin = null;
        }
    
        random_dec()
        {
            // Returns a value between [0, 1)
            this.seed ^= this.seed << 13;
            this.seed ^= this.seed >> 17;
            this.seed ^= this.seed << 5;
            count++;
            return ((this.seed < 0 ? ~this.seed + 1 : this.seed) % RANDOM_DEC_PRECISION) / RANDOM_DEC_PRECISION;
         
        }
    
         random_num(a, b)
        {
            // Returns a value between [a, b)
            return a + (b - a) * this.random_dec();
        }
    
        random_int(a, b)
        {
            // Returns an integer between [a, b]
            return Math.floor(this.random_num(a, b+1));
        }
    
        random_choice(x)
        {
            // Returns an element from list (x must be a list)
            return x[Math.floor(this.random_num(0, x.length * 0.99))];
        }
      
        // random boolean with p as percent liklihood of true
        random_bool(p) {
            return this.random_dec() < p;
      }
    
        noise(x, y) 
        {
            // Perlin noise function for 2 dimensions, based on p5js noise function
            // Receives x and y coordinates
            // Returns a value between (0, 1)
    
            if (this.perlin == null) {
                this.perlin = new Array(PERLIN_SIZE + 1);
                for (let i = 0; i < PERLIN_SIZE + 1; i++) {
                    this.perlin[i] = this.random_dec();
                }
            }
    
            if (x < 0) {
                x = -x;
            }
            if (y < 0) {
                y = -y;
            }
    
            let xi = Math.floor(x), yi = Math.floor(y);
            let xf = x - xi;
            let yf = y - yi;
            let rxf, ryf;
    
            let r = 0;
            let ampl = 0.5;
    
            let n1, n2, n3;
    
            for (let o = 0; o < PERLIN_OCTAVES; o++) {
                let of = xi + (yi << PERLIN_YWRAPB);
    
                rxf = scaled_cosine(xf);
                ryf = scaled_cosine(yf);
    
                n1 = this.perlin[of & PERLIN_SIZE];
                n1 += rxf * (this.perlin[(of + 1) & PERLIN_SIZE] - n1);
                n2 = this.perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
                n2 += rxf * (this.perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);
                n1 += ryf * (n2 - n1);
    
                of += PERLIN_ZWRAP;
                n2 = this.perlin[of & PERLIN_SIZE];
                n2 += rxf * (this.perlin[(of + 1) & PERLIN_SIZE] - n2);
                n3 = this.perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
                n3 += rxf * (this.perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);
                n2 += ryf * (n3 - n2);
    
                n1 += n2 - n1;
    
                r += n1 * ampl;
                ampl *= PERLIN_AMP_FALLOFF;
                xi <<= 1;
                xf *= 2;
                yi <<= 1;
                yf *= 2;
    
                if (xf >= 1.0) {
                    xi++;
                    xf--;
                }
                if (yf >= 1.0) {
                    yi++;
                    yf--;
                }
            }
            return r;
        }
    }
      class Widget{
      constructor(_loc, _hidden, _numC, _color){
        //loc vector (x,y)
        this.loc = _loc;
        this.hidden = _hidden;
        this.numC = _numC;
        this.color = _color;
        //prev Widget?
        //next Widget?
      }
    }
    let myColors = [["#1D90F3", "#FFFE03","#cd2826"],["#fe3233", "#328efd","#fe3233", "#328efd", "#ae8b61", "#d60000"], ["#0380d3", "#3acc4d", "#fa7b14", "#e91629"],[ "#FDCD0B", "#F78023", "#DB1C23", "#E660A2", "#0B6EB3"],["#553A71", "#6184DB", "#50C5B7", "#9CEC5B", "#F0F465"], ["#cf3d5e", "#ff7a17", "#80aae0", "#8d598f", "#0168d0"], ["#ede0ac", "#cab2c8", "#78A36A", "#938dcd", "#83b9d3", "#dd726a"], ["#f96f69","#ffcdd7", "#9ee680", "#ff865d", "#fdea71", "#43c2e2"], ["#20be2b","#7c25a8", "#ffe127", "#f10712", "#135ebb"],["#FF9F1C", "#00D2FF ", "#FFCB61 ", "#B0003A "]];
    
    
    
    var wids = [];
    var pal;
    var spacing;
    var xrayMode = false, toyMode = false, chromie = false, whiteOut = false, blackOut = false, bgColorMode = false, bgBlackMode = false, gridMode = false, grid = false;
    var numPieces = 0;
    var palNum;
    var sc = 0.5;
    var startColor;
    let hideCounter = 0;
    let R;
    var sortMode;
    var DEFAULT_SIZE = 1024
    
    var DIM  = DEFAULT_SIZE;
    var M = DIM / DEFAULT_SIZE;
    
      
      R = new RandomAB(parseInt(tokenData.hash.slice(0, 16), 16));
      console.log("Hash: " + hash)
       //pal = R.random_choice(myColors)
      palNum = R.random_int(0, myColors.length - 1);
      pal = myColors[palNum];
      console.log("Pal: " + pal + "PalNum: " + palNum)
    
    
      spacing = R.random_num(170,385)*M;
      //Start color for Chromie mode
      startColor = R.random_int(0,255);
      if(R.random_bool(.30))grid=true
      
        //Trait test
        //Toy mode or regular black body/lines
        if(R.random_bool(.60) )toyMode = true;
        if(R.random_bool(.28) )xrayMode = true;
        if(R.random_bool(.60)) sc = 1;
        if(R.random_bool(.07) && !chromie) blackOut = true;
        if(R.random_bool(.07) && !blackOut && !chromie) whiteOut = true;
    
      
    //end setup
    
    
    
      
        let hx = DIM/2;
        let hy = DIM/2;
        let headW = DIM*.75;
        let headH = DIM*.75;
      
      if(!grid){
        // Might need to rethink this loop... 
        // Probably should figure out length first and then do while?
        // My thought was to do a sampling in a bounded region using minDist
        // and spacing to get the pieces. 
        //  TODO relook - probably super ineffiencent but wanted good sampling roughly in middle
       for(let i = 0; i < 750; i++){
    
        let x = R.random_num(hx-headW/2, hx+headW/2);
        let y = R.random_num(hy-headH/2, hy+headH/2);
         
       //bounding ellipse test for debug
      /*
         stroke(0)
         strokeWeight(4)
         noFill();
         ellipse(hx,hy,headW,headH)
         ellipse(x,y,16);
      */
       
        
         if(((Math.pow((x-hx),2)/(Math.pow(headW/2,2)))+(Math.pow((y-hy),2)/(Math.pow(headH/2,2)))) < 1 && minDist(x,y, wids, spacing) ){
           //  loc = createVector(x,y)
            let loc = {
                "x":x,
                "y":y
            }
            //hide - to not draw line?
            let hide = false;
            if(R.random_bool(.15) && hideCounter < wids.length-2){
              hide = true;
              hideCounter++
            }
             //insert new widget at x,y, hidden? and random color from palette
             wids.push(new Widget(loc,hide,0, R.random_choice(pal) ));
        }
              
    }
        
      }else{
            // Grid layout
            console.log("Grid layout");
        for(let i = hx-headW/3; i <= hx+headW/3; i+= headW/3){
             for(let yy = hy-headH/3; yy <= hy+headH/3; yy+= headH/3){
                   //hide - to not draw line?
               let hide = false;
              if(R.random_bool(.25)){
                  hide = true;
                  hideCounter++
              }
           // Pivot from p5js vector 
           //  let  loc = createVector(i,yy)
              let loc = {
                "x":i,
                "y":yy
            }
             wids.push(new Widget(loc,hide,0, R.random_choice(pal) ));
            }
        }
    
      }
    
        //debug
       console.log("Hidden: " + hideCounter)
       console.log("Wids len: " + wids.length)
      
      //Which sort for the points
      switch(R.random_int(0, 5)){
          case 0:
            console.log("Left to Right");
            //bblSortOnX(wids);
            sortMode = "Left to Right";
            break;
          case 1:
             console.log("Top to Bottom");
           // bblSortOnY(wids);
          sortMode = "Top to Bottom";
            break;
          case 2:
           console.log("Here and There");
           // bblSortOnYX(wids);
          //Not quite rng maybe better name is Y/X. Doesn't make much sense either tho
          sortMode = "Here and There"; 
            break;  
          case 3:
           console.log("Circle");
          // circleSort(wids);
          //Sometimes let's close the circle - implicit trait
          if (R.random_bool(.12)) wids.push(wids[0]);  
          sortMode = "Circle"
            break; 
          case 4:
           console.log("Diagonal");
          //orginSort(wids);
          sortMode = "Diagonal"
            break;   
            
          default:
           // bblSortOnYX(wids);
           console.log("Here and There");
            sortMode = "Here and There"
            break; 
          
      }
      
      //Want clean chromie pieces - no hidden and min length    
      if (R.random_bool(.15) && wids.length > 6 && hideCounter == 0) chromie = true;
      // Backgrounds - no color with chromie only default and black
      //TODO in setup? Though chromie is dependent on wids len and hideCounter
      if(R.random_bool(.23) && !chromie)bgColorMode = true;
      
        if(R.random_bool(.25) && !bgColorMode && toyMode){
         bgBlackMode = true
          //background(5)
         }
        if(bgColorMode){
          let bgColor =  R.random_choice(pal);
         // background(hue(bgColor), 150,120);
        } 
    //
      
      
      //Trait debug stuff as messing with feature script
      console.log(wids.length)
      console.log("toy: " + toyMode + ", blackOut: "+ blackOut + ", whiteOut: "+ whiteOut);
      let bg = "Plain";
      if(bgBlackMode)bg = "Dark";
      if(bgColorMode)bg = "Color";
      
      console.log("BG: " + bg)
       let md = "Pieces";
      if(!toyMode) md = "Solid"
      console.log("Toy Mode: " + md)
       
       if(!toyMode){
        for(let z = 0; z < wids.length-1; z++){
          
     
          //skip the line for z or z+1 - to create solo points or break the chain
          if(wids[z].hidden || wids[z+1].hidden) continue;
          //
    
        //  line(wids[z].loc.x, wids[z].loc.y,wids[z+1].loc.x, wids[z+1].loc.y);
            numPieces++;
          }
        }
    
      
        //Main loop for the lines and points
        // TODO - simplify loop and clean up Chromie part 
        for(let p = 0; p < wids.length; p++){
    
          
          if(wids[p].hidden == false){
            
            if(toyMode){
              if((p+1) == wids.length )break;
    
            numPieces++;
          }
            if(R.random_bool(0.20)){
           let rndRad = R.random_num(64,155) * sc * M;
       
             
              if(R.random_bool(0.5)){
    
                
              }
             
               } else{
                       let er = R.random_num(64, 155) * sc * M;
         
                 if(R.random_bool(0.15)){
                  let rC = R.random_choice(pal);
       
                  
                 }
    
               }
    
    
          if((p+1) == wids.length )break;
    
          }
      
        }
        grainTexture();
    
     // fill(0, 25, 200)
        let palName = "";
        switch(palNum){
          case 0:
            palName = "Superhero";
            break;
          case 1:
            palName = "8006";
            break;
            case 2:
            palName = "Bounce House";
            break;
            case 3:
            palName = "Bricks";
            break;
            case 4: 
            palName = "Dinosaur";
            break;
            case 5:
            palName = "Sunset";
            break;
            case 6:
            palName = "Princess";
            break;
            case 7:
            palName = "Pool Party";
            break;
            case 8:
            palName = "Marble Run";
            break;
            case 9:
            palName = "Robot";
            break;  
        }
      if(chromie)palName = "Chromie";
            let scl = "";
            if(sc == 0.5) {
              scl = "Regular"} else{scl = "Large"}
    
      let layout = "Normal";
      if(grid) layout = "Grid";
    
      let toyFill = "Normal";
      if(blackOut) toyFill = "Blackout";
      if(whiteOut) toyFill = "Whiteout";
          
       /*
       * For example, this should return `{"Palette": "Rosy", "Scale": "Big", "Tilt": 72}` if the desired features for a mint were:
       * - Palette: Rosy
       * - Scale: Big
       * - Tilt: 72
       */
        console.log("Count: " + count)
      return {
        "Colors": palName,
        "Toy Mode": md, 
        "Toy Size": scl,
        "Order": sortMode,
        "Paper": bg,
        "Grid": grid,
        "X-Ray": xrayMode,
        "Toy Pieces:": numPieces
      }
    
      
    function minDist(x,y,points, distance){
      for (let i = 0; i < points.length; i++){
        if(dist2(x,y,points[i].loc.x, points[i].loc.y) < distance)return false;
      }
      return true;
    }
    
    
    function dist2 (x1, y1, x2, y2) {
    var a = x1 - x2;
    var b = y1 - y2;
    
    var c = Math.sqrt( a*a + b*b );
    
      return (c);
    };
      
      function grainTexture(){
      //loadPixels();
      //noiseDetail(2, .5)
    
      for (let y = 0; y < 1024; y++) {
        for (let x = 0; x < 1024; x++) {
          let index = (x + y * 1024) * 4;
          //let r = pixels[index];
         // let g = pixels[index + 1];
        //  let b = pixels[index + 2];
        //  let a = pixels[index + 3];
    
        let grain = x + R.random_num(-10, 10) + R.random_num(-10, 10) * 32;
        //  pixels[index] = r + grain;
         // pixels[index + 1] = g + grain;
         // pixels[index + 2] = b + grain;
        //  pixels[index + 3] = a;
        }
      }
    //  updatePixels();
    }
}